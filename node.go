package abnf

import (
	"bytes"
	"hash/fnv"
	"strconv"
	"sync"

	lru "github.com/hashicorp/golang-lru/v2"
)

var (
	NodesCap      = 100
	NodeCacheSize = 512
)

// Node represents a single node in a tree generated by [Operator].
type Node struct {
	Key      string
	Pos      uint
	Value    []byte
	Children Nodes
}

// String returns the node's value as string.
func (n *Node) String() string {
	if n == nil {
		return ""
	}
	return string(n.Value)
}

// Len returns length of the node's value.
func (n *Node) Len() int {
	if n == nil {
		return 0
	}
	return len(n.Value)
}

// IsEmpty returns true if the node's value length = 0.
func (n *Node) IsEmpty() bool { return n == nil || len(n.Value) == 0 }

// Contains returns whether the subtree contains the given key.
func (n *Node) Contains(key string) bool {
	if n == nil {
		return false
	}
	_, ok := n.GetNode(key)
	return ok
}

// GetNode recursively searches a node with the given key starting from itself.
// Returns found node or nil if not found.
func (n *Node) GetNode(key string) (*Node, bool) {
	if n == nil {
		return nil, false
	}
	if n.Key == key {
		return n, true
	}
	return n.Children.Get(key)
}

// GetNodes recursively searches all nodes with the given key starting from itself.
func (n *Node) GetNodes(key string) Nodes {
	if n == nil {
		return nil
	}

	var ns Nodes
	if n.Key == key {
		ns = append(ns, n)
	}
	ns = append(ns, n.Children.GetAll(key)...)
	return ns
}

// Compare compares node values via [bytes.Compare].
// The result will be 0 if n.Value == other.Value, -1 if n.Value < other.Value, and +1 if n.Value > other.Value.
func (n *Node) Compare(other *Node) int {
	if n == other {
		return 0
	} else if n == nil {
		return -1
	} else if other == nil {
		return 1
	}
	return bytes.Compare(n.Value, other.Value)
}

var nodeCache, _ = lru.New[uint64, *Node](NodeCacheSize)

type nodeCacheKey struct {
	key   string
	pos   uint
	len   uint
	input []byte
	child []byte
}

func (key *nodeCacheKey) hash() uint64 {
	h := fnv.New64a()
	h.Write([]byte(key.key))
	h.Write([]byte(strconv.FormatUint(uint64(key.pos), 10)))
	h.Write([]byte(strconv.FormatUint(uint64(key.len), 10)))
	h.Write(key.input)
	h.Write(key.child)
	return h.Sum64()
}

func hashKeys(nn *Nodes) []byte {
	h := fnv.New64a()
	for _, n := range *nn {
		h.Write([]byte(n.Key))
		h.Write(hashKeys(&n.Children))
	}
	return h.Sum(nil)
}

func hashString(s []byte) []byte {
	h := fnv.New64a()
	h.Write(s)
	return h.Sum(nil)
}

func loadNode(k nodeCacheKey) (*Node, bool) {
	n, ok := nodeCache.Get(k.hash())
	if !ok {
		return nil, false
	}
	return n, true
}

func storeNode(k nodeCacheKey, n *Node) {
	nodeCache.Add(k.hash(), n)
}

func loadOrStoreNode(k nodeCacheKey, newNode func() *Node) *Node {
	if n, ok := loadNode(k); ok {
		return n
	}

	n := newNode()
	storeNode(k, n)
	return n
}

// Nodes represents a list of nodes.
type Nodes []*Node

// Contains returns whether the subtree contains the given key.
func (ns Nodes) Contains(key string) bool {
	for _, n := range ns {
		if n.Key == key || n.Children.Contains(key) {
			return true
		}
	}
	return false
}

// Get recursively searches a node with the given key.
func (ns Nodes) Get(key string) (*Node, bool) {
	for _, n := range ns {
		if n.Key == key {
			return n, true
		}
		if n, ok := n.Children.Get(key); ok {
			return n, true
		}
	}
	return nil, false
}

// GetAll recursively searches all nodes with the given key.
func (ns Nodes) GetAll(key string) Nodes {
	var nodes Nodes
	for _, n := range ns {
		if n.Key == key {
			nodes = append(nodes, n)
		}
		nodes = append(nodes, n.Children.GetAll(key)...)
	}
	return nodes
}

// Best returns a node with the longest value or nil if the list is empty.
func (ns Nodes) Best() *Node {
	if len(ns) == 0 {
		return nil
	}

	best := ns[0]
	for _, n := range ns[1:] {
		if n.Len() > best.Len() {
			best = n
		}
	}
	return best
}

// Compare compares two best nodes.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b where a - self best node, b - other best node.
func (ns Nodes) Compare(other Nodes) int {
	return ns.Best().Compare(other.Best())
}

func (ns *Nodes) Append(n ...*Node) {
	*ns = append(*ns, n...)
}

var nsPool = &sync.Pool{
	New: func() any {
		ns := make(Nodes, 0, NodesCap)
		return &ns
	},
}

// NewNodes returns a new nodes list from the pool.
func NewNodes() Nodes {
	ns := nsPool.Get().(*Nodes)
	return *ns
}

// Clear clears the nodes list.
func (ns *Nodes) Clear() {
	if ns == nil {
		return
	}

	clear(*ns)
	*ns = (*ns)[:0]
}

// Free returns the nodes list to the pool.
func (ns *Nodes) Free() {
	ns.Clear()

	if ns == nil || cap(*ns) == 0 || cap(*ns) > 2*NodesCap {
		return
	}

	nsPool.Put(ns)
}
