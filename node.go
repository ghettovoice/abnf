package abnf

import (
	"bytes"
	"encoding/binary"
	"hash"
	"hash/fnv"
	"sync"
	"sync/atomic"
	"unsafe"

	lru "github.com/hashicorp/golang-lru/v2"
)

// Node represents a single node in a tree generated by [Operator].
type Node struct {
	Key      string
	Pos      uint
	Value    []byte
	Children Nodes
}

// String returns the node's value as string.
func (n *Node) String() string {
	if n == nil {
		return ""
	}
	return string(n.Value)
}

// Len returns length of the node's value.
func (n *Node) Len() int {
	if n == nil {
		return 0
	}
	return len(n.Value)
}

// IsEmpty returns true if the node's value length = 0.
func (n *Node) IsEmpty() bool { return n == nil || len(n.Value) == 0 }

// Contains returns whether the subtree contains the given key.
func (n *Node) Contains(key string) bool {
	if n == nil {
		return false
	}
	_, ok := n.GetNode(key)
	return ok
}

// GetNode recursively searches a node with the given key starting from itself.
// Returns found node or nil if not found.
func (n *Node) GetNode(key string) (*Node, bool) {
	if n == nil {
		return nil, false
	}
	if n.Key == key {
		return n, true
	}
	return n.Children.Get(key)
}

// GetNodes recursively searches all nodes with the given key starting from itself.
func (n *Node) GetNodes(key string) Nodes {
	if n == nil {
		return nil
	}

	var ns Nodes
	if n.Key == key {
		ns = append(ns, n)
	}
	ns = append(ns, n.Children.AllByKey(key)...)
	return ns
}

// Compare compares node values via [bytes.Compare].
// The result will be 0 if n.Value == other.Value, -1 if n.Value < other.Value, and +1 if n.Value > other.Value.
func (n *Node) Compare(other *Node) int {
	if n == other {
		return 0
	} else if n == nil {
		return -1
	} else if other == nil {
		return 1
	}
	return bytes.Compare(n.Value, other.Value)
}

var nodeCache atomic.Pointer[lru.Cache[uint64, *Node]]

// EnableNodeCache initializes the node cache.
// If size is 0, it will be set to 1024.
// By default, the cache is disabled.
// It does nothing if the cache is already enabled.
// Call this function before using any [Operator], usually in the [init].
func EnableNodeCache(size uint) {
	if nodeCache.Load() != nil {
		return
	}

	if size == 0 {
		size = 1024
	}

	cache, _ := lru.New[uint64, *Node](int(size))
	nodeCache.Store(cache)
}

// ResizeNodeCache resizes the node cache.
// If size is 0, it will be set to 1024.
// It does nothing if the cache is disabled.
// It is safe to call this function from multiple goroutines.
func ResizeNodeCache(size uint) {
	if size == 0 {
		size = 1024
	}

	if cache := nodeCache.Load(); cache != nil {
		cache.Resize(int(size))
	}
}

// DisableNodeCache disables the node cache and purges all cached nodes.
// It does nothing if the cache is already disabled.
// It is safe to call this function from multiple goroutines.
func DisableNodeCache() {
	if cache := nodeCache.Swap(nil); cache != nil {
		cache.Purge()
	}
}

type nodeCacheKey struct {
	hash.Hash64
	buf [8]byte
}

var nodeCacheKeyPool = sync.Pool{
	New: func() any { return &nodeCacheKey{fnv.New64a(), [8]byte{}} },
}

func newNodeCacheKey(key string, pos uint, len uint, input []byte, ns ...*Node) *nodeCacheKey {
	ck := nodeCacheKeyPool.Get().(*nodeCacheKey)
	ck.writeBase(key, pos, len, input)
	ck.writeChildKeys(0, ns...)
	return ck
}

func (ck *nodeCacheKey) free() {
	if ck == nil {
		return
	}

	ck.Reset()
	nodeCacheKeyPool.Put(ck)
}

func (ck *nodeCacheKey) writeBase(key string, pos, length uint, input []byte) {
	ck.Write(unsafeStringToBytes(key))

	binary.BigEndian.PutUint64(ck.buf[:], uint64(pos))
	ck.Write(ck.buf[:])

	binary.BigEndian.PutUint64(ck.buf[:], uint64(length))
	ck.Write(ck.buf[:])

	if len(input) == 0 || length == 0 {
		return
	}

	start := int(pos)
	if start >= len(input) {
		return
	}
	end := min(start+int(length), len(input))
	ck.Write(input[start:end])
}

func (ck *nodeCacheKey) writeChildKeys(depth uint, ns ...*Node) {
	for _, n := range ns {
		binary.BigEndian.PutUint64(ck.buf[:], uint64(depth))
		ck.Write(ck.buf[:])
		ck.Write(unsafeStringToBytes(n.Key))
		ck.writeChildKeys(depth+1, n.Children...)
	}
}

func (ck *nodeCacheKey) hash() uint64 { return ck.Sum64() }

// unsafeStringToBytes converts string to []byte without allocation
// WARNING: The returned byte slice must not be modified
func unsafeStringToBytes(s string) []byte {
	return *(*[]byte)(unsafe.Pointer(&struct {
		string
		int
	}{s, len(s)}))
}

func loadNode(k *nodeCacheKey) (*Node, bool) {
	cache := nodeCache.Load()
	if cache == nil {
		return nil, false
	}

	n, ok := cache.Get(k.hash())
	if !ok {
		return nil, false
	}
	return n, true
}

func storeNode(k *nodeCacheKey, n *Node) {
	cache := nodeCache.Load()
	if cache == nil {
		return
	}

	cache.Add(k.hash(), n)
}

func loadOrStoreNode(k *nodeCacheKey, newNode func() *Node) *Node {
	defer k.free()

	cache := nodeCache.Load()
	if cache == nil {
		return newNode()
	}

	if n, ok := loadNode(k); ok {
		return n
	}

	n := newNode()
	storeNode(k, n)
	return n
}

// Nodes represents a list of nodes.
type Nodes []*Node

func (ns *Nodes) Len() int {
	if ns == nil {
		return 0
	}
	return len(*ns)
}

// Contains returns whether the subtree contains the given key.
func (ns *Nodes) Contains(key string) bool {
	if ns == nil {
		return false
	}

	for _, n := range *ns {
		if n.Key == key || n.Children.Contains(key) {
			return true
		}
	}
	return false
}

// Get recursively searches a node with the given key.
func (ns *Nodes) Get(key string) (*Node, bool) {
	if ns == nil {
		return nil, false
	}

	for _, n := range *ns {
		if n.Key == key {
			return n, true
		}
		if n, ok := n.Children.Get(key); ok {
			return n, true
		}
	}
	return nil, false
}

// All returns all nodes in the list.
func (ns *Nodes) All() Nodes {
	if ns == nil {
		return nil
	}
	return *ns
}

// GetAll recursively searches all nodes with the given key.
func (ns *Nodes) AllByKey(key string) Nodes {
	if ns == nil {
		return nil
	}

	var nodes Nodes
	for _, n := range *ns {
		if n.Key == key {
			nodes = append(nodes, n)
		}
		nodes = append(nodes, n.Children.AllByKey(key)...)
	}
	return nodes
}

// Best returns a node with the longest value or nil if the list is empty.
func (ns *Nodes) Best() *Node {
	if ns == nil || len(*ns) == 0 {
		return nil
	}

	best := (*ns)[0]
	for _, n := range (*ns)[1:] {
		if n.Len() > best.Len() {
			best = n
		}
	}
	return best
}

// Compare compares two best nodes.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b where a - self best node, b - other best node.
func (ns *Nodes) Compare(other *Nodes) int {
	if ns == nil || other == nil {
		return 0
	}
	return ns.Best().Compare(other.Best())
}

func (ns *Nodes) Append(n ...*Node) {
	*ns = append(*ns, n...)
}

// NodesCap is a initial capacity of a new nodes list.
var NodesCap = 10

var nodesPool = &sync.Pool{
	New: func() any {
		ns := make(Nodes, 0, NodesCap)
		return &ns
	},
}

// NewNodes returns a new nodes list from the pool.
func NewNodes() *Nodes {
	return nodesPool.Get().(*Nodes)
}

// Clear clears the nodes list.
func (ns *Nodes) Clear() {
	if ns == nil {
		return
	}

	clear(*ns)
	*ns = (*ns)[:0]
}

// Free returns the nodes list to the pool.
func (ns *Nodes) Free() {
	ns.Clear()

	if ns == nil || cap(*ns) == 0 || cap(*ns) > 10*NodesCap {
		return
	}

	nodesPool.Put(ns)
}

type nodesSorter Nodes

func (ns *nodesSorter) Len() int { return len(*ns) }

func (ns *nodesSorter) Less(i, j int) bool {
	return len((*ns)[i].Value) > len((*ns)[j].Value) ||
		len((*ns)[i].Children) > len((*ns)[j].Children) ||
		(*ns)[i].Pos < (*ns)[j].Pos ||
		(*ns)[i].Key < (*ns)[j].Key
}

func (ns *nodesSorter) Swap(i, j int) { (*ns)[i], (*ns)[j] = (*ns)[j], (*ns)[i] }
