// This file is generated by abnf - DO NOT EDIT.

package abnf_def

import (
	"sync"

	"github.com/ghettovoice/abnf"
	"github.com/ghettovoice/abnf/pkg/abnf_core"
)

var (
	oprsDescr  = &OperatorsDescr{}
	rulesDescr = &RulesDescr{}
)

// Operators returns operators descriptor.
func Operators() *OperatorsDescr {
	return oprsDescr
}

// Rules returns rules descriptor.
func Rules() *RulesDescr {
	return rulesDescr
}

// OperatorsMap returns map of all operators.
func OperatorsMap() map[string]abnf.Operator {
	return map[string]abnf.Operator{
		"alternation":             oprsDescr.Alternation,
		"bin-val":                 oprsDescr.BinVal,
		"c-nl":                    oprsDescr.CNl,
		"c-wsp":                   oprsDescr.CWsp,
		"case-insensitive-string": oprsDescr.CaseInsensitiveString,
		"case-sensitive-string":   oprsDescr.CaseSensitiveString,
		"char-val":                oprsDescr.CharVal,
		"comment":                 oprsDescr.Comment,
		"concatenation":           oprsDescr.Concatenation,
		"dec-val":                 oprsDescr.DecVal,
		"defined-as":              oprsDescr.DefinedAs,
		"element":                 oprsDescr.Element,
		"elements":                oprsDescr.Elements,
		"group":                   oprsDescr.Group,
		"hex-val":                 oprsDescr.HexVal,
		"num-val":                 oprsDescr.NumVal,
		"option":                  oprsDescr.Option,
		"prose-val":               oprsDescr.ProseVal,
		"quoted-string":           oprsDescr.QuotedString,
		"repeat":                  oprsDescr.Repeat,
		"repetition":              oprsDescr.Repetition,
		"rule":                    oprsDescr.Rule,
		"rulelist":                oprsDescr.Rulelist,
		"rulename":                oprsDescr.Rulename,
	}
}

// RulesMap returns map of all rules.
func RulesMap() map[string]abnf.Rule {
	return map[string]abnf.Rule{
		"alternation":             rulesDescr.Alternation,
		"bin-val":                 rulesDescr.BinVal,
		"c-nl":                    rulesDescr.CNl,
		"c-wsp":                   rulesDescr.CWsp,
		"case-insensitive-string": rulesDescr.CaseInsensitiveString,
		"case-sensitive-string":   rulesDescr.CaseSensitiveString,
		"char-val":                rulesDescr.CharVal,
		"comment":                 rulesDescr.Comment,
		"concatenation":           rulesDescr.Concatenation,
		"dec-val":                 rulesDescr.DecVal,
		"defined-as":              rulesDescr.DefinedAs,
		"element":                 rulesDescr.Element,
		"elements":                rulesDescr.Elements,
		"group":                   rulesDescr.Group,
		"hex-val":                 rulesDescr.HexVal,
		"num-val":                 rulesDescr.NumVal,
		"option":                  rulesDescr.Option,
		"prose-val":               rulesDescr.ProseVal,
		"quoted-string":           rulesDescr.QuotedString,
		"repeat":                  rulesDescr.Repeat,
		"repetition":              rulesDescr.Repetition,
		"rule":                    rulesDescr.Rule,
		"rulelist":                rulesDescr.Rulelist,
		"rulename":                rulesDescr.Rulename,
	}
}

// OperatorsDescr defines operators descriptor that provides operators as methods.
type OperatorsDescr struct {
	alternation               abnf.Operator
	alternationOnce           sync.Once
	binVal                    abnf.Operator
	binValOnce                sync.Once
	cNl                       abnf.Operator
	cNlOnce                   sync.Once
	cWsp                      abnf.Operator
	cWspOnce                  sync.Once
	caseInsensitiveString     abnf.Operator
	caseInsensitiveStringOnce sync.Once
	caseSensitiveString       abnf.Operator
	caseSensitiveStringOnce   sync.Once
	charVal                   abnf.Operator
	charValOnce               sync.Once
	comment                   abnf.Operator
	commentOnce               sync.Once
	concatenation             abnf.Operator
	concatenationOnce         sync.Once
	decVal                    abnf.Operator
	decValOnce                sync.Once
	definedAs                 abnf.Operator
	definedAsOnce             sync.Once
	element                   abnf.Operator
	elementOnce               sync.Once
	elements                  abnf.Operator
	elementsOnce              sync.Once
	group                     abnf.Operator
	groupOnce                 sync.Once
	hexVal                    abnf.Operator
	hexValOnce                sync.Once
	numVal                    abnf.Operator
	numValOnce                sync.Once
	option                    abnf.Operator
	optionOnce                sync.Once
	proseVal                  abnf.Operator
	proseValOnce              sync.Once
	quotedString              abnf.Operator
	quotedStringOnce          sync.Once
	repeat                    abnf.Operator
	repeatOnce                sync.Once
	repetition                abnf.Operator
	repetitionOnce            sync.Once
	rule                      abnf.Operator
	ruleOnce                  sync.Once
	rulelist                  abnf.Operator
	rulelistOnce              sync.Once
	rulename                  abnf.Operator
	rulenameOnce              sync.Once
}

// Alternation operator: alternation = concatenation *(*c-wsp "/" *c-wsp concatenation)
func (desc *OperatorsDescr) Alternation(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.alternationOnce.Do(func() {
		desc.alternation = abnf.Concat(
			"alternation",
			desc.Concatenation,
			abnf.Repeat0Inf(
				"*(*c-wsp \"/\" *c-wsp concatenation)",
				abnf.Concat(
					"*c-wsp \"/\" *c-wsp concatenation",
					abnf.Repeat0Inf(
						"*c-wsp",
						desc.CWsp,
					),
					abnf.Literal("\"/\"", []byte{47}),
					abnf.Repeat0Inf(
						"*c-wsp",
						desc.CWsp,
					),
					desc.Concatenation,
				),
			),
		)
	})
	return desc.alternation(in, pos, ns) //errtrace:skip
}

// BinVal operator: bin-val = "b" 1*BIT [ 1*("." 1*BIT) / ("-" 1*BIT) ]
func (desc *OperatorsDescr) BinVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.binValOnce.Do(func() {
		desc.binVal = abnf.Concat(
			"bin-val",
			abnf.Literal("\"b\"", []byte{98}),
			abnf.Repeat1Inf(
				"1*BIT",
				abnf_core.Operators().BIT,
			),
			abnf.Optional(
				"[ 1*(\".\" 1*BIT) / (\"-\" 1*BIT) ]",
				abnf.Alt(
					"1*(\".\" 1*BIT) / (\"-\" 1*BIT)",
					abnf.Repeat1Inf(
						"1*(\".\" 1*BIT)",
						abnf.Concat(
							"\".\" 1*BIT",
							abnf.Literal("\".\"", []byte{46}),
							abnf.Repeat1Inf(
								"1*BIT",
								abnf_core.Operators().BIT,
							),
						),
					),
					abnf.Concat(
						"\"-\" 1*BIT",
						abnf.Literal("\"-\"", []byte{45}),
						abnf.Repeat1Inf(
							"1*BIT",
							abnf_core.Operators().BIT,
						),
					),
				),
			),
		)
	})
	return desc.binVal(in, pos, ns) //errtrace:skip
}

// CNl operator: c-nl = comment / CRLF
func (desc *OperatorsDescr) CNl(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.cNlOnce.Do(func() {
		desc.cNl = abnf.Alt(
			"c-nl",
			desc.Comment,
			abnf_core.Operators().CRLF,
		)
	})
	return desc.cNl(in, pos, ns) //errtrace:skip
}

// CWsp operator: c-wsp = WSP / (c-nl WSP)
func (desc *OperatorsDescr) CWsp(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.cWspOnce.Do(func() {
		desc.cWsp = abnf.Alt(
			"c-wsp",
			abnf_core.Operators().WSP,
			abnf.Concat(
				"c-nl WSP",
				desc.CNl,
				abnf_core.Operators().WSP,
			),
		)
	})
	return desc.cWsp(in, pos, ns) //errtrace:skip
}

// CaseInsensitiveString operator: case-insensitive-string = [ "%i" ] quoted-string
func (desc *OperatorsDescr) CaseInsensitiveString(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.caseInsensitiveStringOnce.Do(func() {
		desc.caseInsensitiveString = abnf.Concat(
			"case-insensitive-string",
			abnf.Optional(
				"[ \"%i\" ]",
				abnf.Literal("\"%i\"", []byte{37, 105}),
			),
			desc.QuotedString,
		)
	})
	return desc.caseInsensitiveString(in, pos, ns) //errtrace:skip
}

// CaseSensitiveString operator: case-sensitive-string = "%s" quoted-string
func (desc *OperatorsDescr) CaseSensitiveString(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.caseSensitiveStringOnce.Do(func() {
		desc.caseSensitiveString = abnf.Concat(
			"case-sensitive-string",
			abnf.Literal("\"%s\"", []byte{37, 115}),
			desc.QuotedString,
		)
	})
	return desc.caseSensitiveString(in, pos, ns) //errtrace:skip
}

// CharVal operator: char-val = case-insensitive-string / case-sensitive-string
func (desc *OperatorsDescr) CharVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.charValOnce.Do(func() {
		desc.charVal = abnf.Alt(
			"char-val",
			desc.CaseInsensitiveString,
			desc.CaseSensitiveString,
		)
	})
	return desc.charVal(in, pos, ns) //errtrace:skip
}

// Comment operator: comment = ";" *(WSP / VCHAR) CRLF
func (desc *OperatorsDescr) Comment(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.commentOnce.Do(func() {
		desc.comment = abnf.Concat(
			"comment",
			abnf.Literal("\";\"", []byte{59}),
			abnf.Repeat0Inf(
				"*(WSP / VCHAR)",
				abnf.Alt(
					"WSP / VCHAR",
					abnf_core.Operators().WSP,
					abnf_core.Operators().VCHAR,
				),
			),
			abnf_core.Operators().CRLF,
		)
	})
	return desc.comment(in, pos, ns) //errtrace:skip
}

// Concatenation operator: concatenation = repetition *(1*c-wsp repetition)
func (desc *OperatorsDescr) Concatenation(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.concatenationOnce.Do(func() {
		desc.concatenation = abnf.Concat(
			"concatenation",
			desc.Repetition,
			abnf.Repeat0Inf(
				"*(1*c-wsp repetition)",
				abnf.Concat(
					"1*c-wsp repetition",
					abnf.Repeat1Inf(
						"1*c-wsp",
						desc.CWsp,
					),
					desc.Repetition,
				),
			),
		)
	})
	return desc.concatenation(in, pos, ns) //errtrace:skip
}

// DecVal operator: dec-val = "d" 1*DIGIT [ 1*("." 1*DIGIT) / ("-" 1*DIGIT) ]
func (desc *OperatorsDescr) DecVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.decValOnce.Do(func() {
		desc.decVal = abnf.Concat(
			"dec-val",
			abnf.Literal("\"d\"", []byte{100}),
			abnf.Repeat1Inf(
				"1*DIGIT",
				abnf_core.Operators().DIGIT,
			),
			abnf.Optional(
				"[ 1*(\".\" 1*DIGIT) / (\"-\" 1*DIGIT) ]",
				abnf.Alt(
					"1*(\".\" 1*DIGIT) / (\"-\" 1*DIGIT)",
					abnf.Repeat1Inf(
						"1*(\".\" 1*DIGIT)",
						abnf.Concat(
							"\".\" 1*DIGIT",
							abnf.Literal("\".\"", []byte{46}),
							abnf.Repeat1Inf(
								"1*DIGIT",
								abnf_core.Operators().DIGIT,
							),
						),
					),
					abnf.Concat(
						"\"-\" 1*DIGIT",
						abnf.Literal("\"-\"", []byte{45}),
						abnf.Repeat1Inf(
							"1*DIGIT",
							abnf_core.Operators().DIGIT,
						),
					),
				),
			),
		)
	})
	return desc.decVal(in, pos, ns) //errtrace:skip
}

// DefinedAs operator: defined-as = *c-wsp ("=" / "=/") *c-wsp
func (desc *OperatorsDescr) DefinedAs(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.definedAsOnce.Do(func() {
		desc.definedAs = abnf.Concat(
			"defined-as",
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
			abnf.Alt(
				"\"=\" / \"=/\"",
				abnf.Literal("\"=\"", []byte{61}),
				abnf.Literal("\"=/\"", []byte{61, 47}),
			),
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
		)
	})
	return desc.definedAs(in, pos, ns) //errtrace:skip
}

// Element operator: element = rulename / group / option / char-val / num-val / prose-val
func (desc *OperatorsDescr) Element(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.elementOnce.Do(func() {
		desc.element = abnf.Alt(
			"element",
			desc.Rulename,
			desc.Group,
			desc.Option,
			desc.CharVal,
			desc.NumVal,
			desc.ProseVal,
		)
	})
	return desc.element(in, pos, ns) //errtrace:skip
}

// Elements operator: elements = alternation *WSP
func (desc *OperatorsDescr) Elements(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.elementsOnce.Do(func() {
		desc.elements = abnf.Concat(
			"elements",
			desc.Alternation,
			abnf.Repeat0Inf(
				"*WSP",
				abnf_core.Operators().WSP,
			),
		)
	})
	return desc.elements(in, pos, ns) //errtrace:skip
}

// Group operator: group = "(" *c-wsp alternation *c-wsp ")"
func (desc *OperatorsDescr) Group(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.groupOnce.Do(func() {
		desc.group = abnf.Concat(
			"group",
			abnf.Literal("\"(\"", []byte{40}),
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
			desc.Alternation,
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
			abnf.Literal("\")\"", []byte{41}),
		)
	})
	return desc.group(in, pos, ns) //errtrace:skip
}

// HexVal operator: hex-val = "x" 1*HEXDIG [ 1*("." 1*HEXDIG) / ("-" 1*HEXDIG) ]
func (desc *OperatorsDescr) HexVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.hexValOnce.Do(func() {
		desc.hexVal = abnf.Concat(
			"hex-val",
			abnf.Literal("\"x\"", []byte{120}),
			abnf.Repeat1Inf(
				"1*HEXDIG",
				abnf_core.Operators().HEXDIG,
			),
			abnf.Optional(
				"[ 1*(\".\" 1*HEXDIG) / (\"-\" 1*HEXDIG) ]",
				abnf.Alt(
					"1*(\".\" 1*HEXDIG) / (\"-\" 1*HEXDIG)",
					abnf.Repeat1Inf(
						"1*(\".\" 1*HEXDIG)",
						abnf.Concat(
							"\".\" 1*HEXDIG",
							abnf.Literal("\".\"", []byte{46}),
							abnf.Repeat1Inf(
								"1*HEXDIG",
								abnf_core.Operators().HEXDIG,
							),
						),
					),
					abnf.Concat(
						"\"-\" 1*HEXDIG",
						abnf.Literal("\"-\"", []byte{45}),
						abnf.Repeat1Inf(
							"1*HEXDIG",
							abnf_core.Operators().HEXDIG,
						),
					),
				),
			),
		)
	})
	return desc.hexVal(in, pos, ns) //errtrace:skip
}

// NumVal operator: num-val = "%" (bin-val / dec-val / hex-val)
func (desc *OperatorsDescr) NumVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.numValOnce.Do(func() {
		desc.numVal = abnf.Concat(
			"num-val",
			abnf.Literal("\"%\"", []byte{37}),
			abnf.Alt(
				"bin-val / dec-val / hex-val",
				desc.BinVal,
				desc.DecVal,
				desc.HexVal,
			),
		)
	})
	return desc.numVal(in, pos, ns) //errtrace:skip
}

// Option operator: option = "[" *c-wsp alternation *c-wsp "]"
func (desc *OperatorsDescr) Option(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.optionOnce.Do(func() {
		desc.option = abnf.Concat(
			"option",
			abnf.Literal("\"[\"", []byte{91}),
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
			desc.Alternation,
			abnf.Repeat0Inf(
				"*c-wsp",
				desc.CWsp,
			),
			abnf.Literal("\"]\"", []byte{93}),
		)
	})
	return desc.option(in, pos, ns) //errtrace:skip
}

// ProseVal operator: prose-val = "<" *(%x20-3D / %x3F-7E) ">"
func (desc *OperatorsDescr) ProseVal(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.proseValOnce.Do(func() {
		desc.proseVal = abnf.Concat(
			"prose-val",
			abnf.Literal("\"<\"", []byte{60}),
			abnf.Repeat0Inf(
				"*(%x20-3D / %x3F-7E)",
				abnf.Alt(
					"%x20-3D / %x3F-7E",
					abnf.Range("%x20-3D", []byte{32}, []byte{61}),
					abnf.Range("%x3F-7E", []byte{63}, []byte{126}),
				),
			),
			abnf.Literal("\">\"", []byte{62}),
		)
	})
	return desc.proseVal(in, pos, ns) //errtrace:skip
}

// QuotedString operator: quoted-string = DQUOTE *(%x20-21 / %x23-7E) DQUOTE
func (desc *OperatorsDescr) QuotedString(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.quotedStringOnce.Do(func() {
		desc.quotedString = abnf.Concat(
			"quoted-string",
			abnf_core.Operators().DQUOTE,
			abnf.Repeat0Inf(
				"*(%x20-21 / %x23-7E)",
				abnf.Alt(
					"%x20-21 / %x23-7E",
					abnf.Range("%x20-21", []byte{32}, []byte{33}),
					abnf.Range("%x23-7E", []byte{35}, []byte{126}),
				),
			),
			abnf_core.Operators().DQUOTE,
		)
	})
	return desc.quotedString(in, pos, ns) //errtrace:skip
}

// Repeat operator: repeat = 1*DIGIT / (*DIGIT "*" *DIGIT)
func (desc *OperatorsDescr) Repeat(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.repeatOnce.Do(func() {
		desc.repeat = abnf.Alt(
			"repeat",
			abnf.Repeat1Inf(
				"1*DIGIT",
				abnf_core.Operators().DIGIT,
			),
			abnf.Concat(
				"*DIGIT \"*\" *DIGIT",
				abnf.Repeat0Inf(
					"*DIGIT",
					abnf_core.Operators().DIGIT,
				),
				abnf.Literal("\"*\"", []byte{42}),
				abnf.Repeat0Inf(
					"*DIGIT",
					abnf_core.Operators().DIGIT,
				),
			),
		)
	})
	return desc.repeat(in, pos, ns) //errtrace:skip
}

// Repetition operator: repetition = [repeat] element
func (desc *OperatorsDescr) Repetition(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.repetitionOnce.Do(func() {
		desc.repetition = abnf.Concat(
			"repetition",
			abnf.Optional(
				"[repeat]",
				desc.Repeat,
			),
			desc.Element,
		)
	})
	return desc.repetition(in, pos, ns) //errtrace:skip
}

// Rule operator: rule = rulename defined-as elements c-nl
func (desc *OperatorsDescr) Rule(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.ruleOnce.Do(func() {
		desc.rule = abnf.Concat(
			"rule",
			desc.Rulename,
			desc.DefinedAs,
			desc.Elements,
			desc.CNl,
		)
	})
	return desc.rule(in, pos, ns) //errtrace:skip
}

// Rulelist operator: rulelist = 1*( rule / (*WSP c-nl) )
func (desc *OperatorsDescr) Rulelist(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.rulelistOnce.Do(func() {
		desc.rulelist = abnf.Repeat1Inf(
			"rulelist",
			abnf.Alt(
				"rule / (*WSP c-nl)",
				desc.Rule,
				abnf.Concat(
					"*WSP c-nl",
					abnf.Repeat0Inf(
						"*WSP",
						abnf_core.Operators().WSP,
					),
					desc.CNl,
				),
			),
		)
	})
	return desc.rulelist(in, pos, ns) //errtrace:skip
}

// Rulename operator: rulename = ALPHA *(ALPHA / DIGIT / "-")
func (desc *OperatorsDescr) Rulename(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.rulenameOnce.Do(func() {
		desc.rulename = abnf.Concat(
			"rulename",
			abnf_core.Operators().ALPHA,
			abnf.Repeat0Inf(
				"*(ALPHA / DIGIT / \"-\")",
				abnf.Alt(
					"ALPHA / DIGIT / \"-\"",
					abnf_core.Operators().ALPHA,
					abnf_core.Operators().DIGIT,
					abnf.Literal("\"-\"", []byte{45}),
				),
			),
		)
	})
	return desc.rulename(in, pos, ns) //errtrace:skip
}

// RulesDescr defines rules descriptor that provides rules as methods.
type RulesDescr struct{}

// Alternation rule: alternation = concatenation *(*c-wsp "/" *c-wsp concatenation)
func (*RulesDescr) Alternation(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Alternation(in, 0, ns) //errtrace:skip
}

// BinVal rule: bin-val = "b" 1*BIT [ 1*("." 1*BIT) / ("-" 1*BIT) ]
func (*RulesDescr) BinVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.BinVal(in, 0, ns) //errtrace:skip
}

// CNl rule: c-nl = comment / CRLF
func (*RulesDescr) CNl(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CNl(in, 0, ns) //errtrace:skip
}

// CWsp rule: c-wsp = WSP / (c-nl WSP)
func (*RulesDescr) CWsp(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CWsp(in, 0, ns) //errtrace:skip
}

// CaseInsensitiveString rule: case-insensitive-string = [ "%i" ] quoted-string
func (*RulesDescr) CaseInsensitiveString(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CaseInsensitiveString(in, 0, ns) //errtrace:skip
}

// CaseSensitiveString rule: case-sensitive-string = "%s" quoted-string
func (*RulesDescr) CaseSensitiveString(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CaseSensitiveString(in, 0, ns) //errtrace:skip
}

// CharVal rule: char-val = case-insensitive-string / case-sensitive-string
func (*RulesDescr) CharVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CharVal(in, 0, ns) //errtrace:skip
}

// Comment rule: comment = ";" *(WSP / VCHAR) CRLF
func (*RulesDescr) Comment(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Comment(in, 0, ns) //errtrace:skip
}

// Concatenation rule: concatenation = repetition *(1*c-wsp repetition)
func (*RulesDescr) Concatenation(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Concatenation(in, 0, ns) //errtrace:skip
}

// DecVal rule: dec-val = "d" 1*DIGIT [ 1*("." 1*DIGIT) / ("-" 1*DIGIT) ]
func (*RulesDescr) DecVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.DecVal(in, 0, ns) //errtrace:skip
}

// DefinedAs rule: defined-as = *c-wsp ("=" / "=/") *c-wsp
func (*RulesDescr) DefinedAs(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.DefinedAs(in, 0, ns) //errtrace:skip
}

// Element rule: element = rulename / group / option / char-val / num-val / prose-val
func (*RulesDescr) Element(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Element(in, 0, ns) //errtrace:skip
}

// Elements rule: elements = alternation *WSP
func (*RulesDescr) Elements(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Elements(in, 0, ns) //errtrace:skip
}

// Group rule: group = "(" *c-wsp alternation *c-wsp ")"
func (*RulesDescr) Group(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Group(in, 0, ns) //errtrace:skip
}

// HexVal rule: hex-val = "x" 1*HEXDIG [ 1*("." 1*HEXDIG) / ("-" 1*HEXDIG) ]
func (*RulesDescr) HexVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.HexVal(in, 0, ns) //errtrace:skip
}

// NumVal rule: num-val = "%" (bin-val / dec-val / hex-val)
func (*RulesDescr) NumVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.NumVal(in, 0, ns) //errtrace:skip
}

// Option rule: option = "[" *c-wsp alternation *c-wsp "]"
func (*RulesDescr) Option(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Option(in, 0, ns) //errtrace:skip
}

// ProseVal rule: prose-val = "<" *(%x20-3D / %x3F-7E) ">"
func (*RulesDescr) ProseVal(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.ProseVal(in, 0, ns) //errtrace:skip
}

// QuotedString rule: quoted-string = DQUOTE *(%x20-21 / %x23-7E) DQUOTE
func (*RulesDescr) QuotedString(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.QuotedString(in, 0, ns) //errtrace:skip
}

// Repeat rule: repeat = 1*DIGIT / (*DIGIT "*" *DIGIT)
func (*RulesDescr) Repeat(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Repeat(in, 0, ns) //errtrace:skip
}

// Repetition rule: repetition = [repeat] element
func (*RulesDescr) Repetition(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Repetition(in, 0, ns) //errtrace:skip
}

// Rule rule: rule = rulename defined-as elements c-nl
func (*RulesDescr) Rule(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Rule(in, 0, ns) //errtrace:skip
}

// Rulelist rule: rulelist = 1*( rule / (*WSP c-nl) )
func (*RulesDescr) Rulelist(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Rulelist(in, 0, ns) //errtrace:skip
}

// Rulename rule: rulename = ALPHA *(ALPHA / DIGIT / "-")
func (*RulesDescr) Rulename(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Rulename(in, 0, ns) //errtrace:skip
}
