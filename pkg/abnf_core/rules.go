// This file is generated by abnf - DO NOT EDIT.

package abnf_core

import "github.com/ghettovoice/abnf"

var alpha abnf.Operator

// ALPHA rule: ALPHA = %x41-5A / %x61-7A
func ALPHA(s []byte, ns abnf.Nodes) abnf.Nodes {
	if alpha == nil {
		alpha = abnf.Alt(
			"ALPHA",
			abnf.Range("%x41-5A", []byte{65}, []byte{90}),
			abnf.Range("%x61-7A", []byte{97}, []byte{122}),
		)
	}
	return alpha(s, ns)
}

var bit abnf.Operator

// BIT rule: BIT = "0" / "1"
func BIT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if bit == nil {
		bit = abnf.Alt(
			"BIT",
			abnf.Literal("\"0\"", []byte{48}),
			abnf.Literal("\"1\"", []byte{49}),
		)
	}
	return bit(s, ns)
}

var char abnf.Operator

// CHAR rule: CHAR = %x01-7F
func CHAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if char == nil {
		char = abnf.Range("CHAR", []byte{1}, []byte{127})
	}
	return char(s, ns)
}

var cr abnf.Operator

// CR rule: CR = %x0D
func CR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cr == nil {
		cr = abnf.Literal("CR", []byte{13})
	}
	return cr(s, ns)
}

var crlf abnf.Operator

// CRLF rule: CRLF = CR LF / LF
func CRLF(s []byte, ns abnf.Nodes) abnf.Nodes {
	if crlf == nil {
		crlf = abnf.Alt(
			"CRLF",
			abnf.Concat(
				"CR LF",
				CR,
				LF,
			),
			LF,
		)
	}
	return crlf(s, ns)
}

var ctl abnf.Operator

// CTL rule: CTL = %x00-1F / %x7F
func CTL(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ctl == nil {
		ctl = abnf.Alt(
			"CTL",
			abnf.Range("%x00-1F", []byte{0}, []byte{31}),
			abnf.Literal("%x7F", []byte{127}),
		)
	}
	return ctl(s, ns)
}

var digit abnf.Operator

// DIGIT rule: DIGIT = %x30-39
func DIGIT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digit == nil {
		digit = abnf.Range("DIGIT", []byte{48}, []byte{57})
	}
	return digit(s, ns)
}

var dquote abnf.Operator

// DQUOTE rule: DQUOTE = %x22
func DQUOTE(s []byte, ns abnf.Nodes) abnf.Nodes {
	if dquote == nil {
		dquote = abnf.Literal("DQUOTE", []byte{34})
	}
	return dquote(s, ns)
}

var hexdig abnf.Operator

// HEXDIG rule: HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F" / "a" / "b" / "c" / "d" / "e" / "f"
func HEXDIG(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hexdig == nil {
		hexdig = abnf.Alt(
			"HEXDIG",
			DIGIT,
			abnf.Literal("\"A\"", []byte{65}),
			abnf.Literal("\"B\"", []byte{66}),
			abnf.Literal("\"C\"", []byte{67}),
			abnf.Literal("\"D\"", []byte{68}),
			abnf.Literal("\"E\"", []byte{69}),
			abnf.Literal("\"F\"", []byte{70}),
			abnf.Literal("\"a\"", []byte{97}),
			abnf.Literal("\"b\"", []byte{98}),
			abnf.Literal("\"c\"", []byte{99}),
			abnf.Literal("\"d\"", []byte{100}),
			abnf.Literal("\"e\"", []byte{101}),
			abnf.Literal("\"f\"", []byte{102}),
		)
	}
	return hexdig(s, ns)
}

var htab abnf.Operator

// HTAB rule: HTAB = %x09
func HTAB(s []byte, ns abnf.Nodes) abnf.Nodes {
	if htab == nil {
		htab = abnf.Literal("HTAB", []byte{9})
	}
	return htab(s, ns)
}

var lf abnf.Operator

// LF rule: LF = %x0A
func LF(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lf == nil {
		lf = abnf.Literal("LF", []byte{10})
	}
	return lf(s, ns)
}

var lwsp abnf.Operator

// LWSP rule: LWSP = *(WSP / CRLF WSP)
func LWSP(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lwsp == nil {
		lwsp = abnf.Repeat0Inf("LWSP", abnf.Alt(
			"WSP / CRLF WSP",
			WSP,
			abnf.Concat(
				"CRLF WSP",
				CRLF,
				WSP,
			),
		))
	}
	return lwsp(s, ns)
}

var octet abnf.Operator

// OCTET rule: OCTET = %x00-FF
func OCTET(s []byte, ns abnf.Nodes) abnf.Nodes {
	if octet == nil {
		octet = abnf.Range("OCTET", []byte{0}, []byte{255})
	}
	return octet(s, ns)
}

var sp abnf.Operator

// SP rule: SP = %x20
func SP(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sp == nil {
		sp = abnf.Literal("SP", []byte{32})
	}
	return sp(s, ns)
}

var vchar abnf.Operator

// VCHAR rule: VCHAR = %x21-7E
func VCHAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if vchar == nil {
		vchar = abnf.Range("VCHAR", []byte{33}, []byte{126})
	}
	return vchar(s, ns)
}

var wsp abnf.Operator

// WSP rule: WSP = SP / HTAB
func WSP(s []byte, ns abnf.Nodes) abnf.Nodes {
	if wsp == nil {
		wsp = abnf.Alt(
			"WSP",
			SP,
			HTAB,
		)
	}
	return wsp(s, ns)
}
