// This file is generated by abnf - DO NOT EDIT.

package abnf_core

import (
	"sync"

	"github.com/ghettovoice/abnf"
)

var (
	oprsDescr  = &OperatorsDescr{}
	rulesDescr = &RulesDescr{}
)

// Operators returns operators descriptor.
func Operators() *OperatorsDescr {
	return oprsDescr
}

// Rules returns rules descriptor.
func Rules() *RulesDescr {
	return rulesDescr
}

// OperatorsMap returns map of all operators.
func OperatorsMap() map[string]abnf.Operator {
	return map[string]abnf.Operator{
		"ALPHA":  oprsDescr.ALPHA,
		"BIT":    oprsDescr.BIT,
		"CHAR":   oprsDescr.CHAR,
		"CR":     oprsDescr.CR,
		"CRLF":   oprsDescr.CRLF,
		"CTL":    oprsDescr.CTL,
		"DIGIT":  oprsDescr.DIGIT,
		"DQUOTE": oprsDescr.DQUOTE,
		"HEXDIG": oprsDescr.HEXDIG,
		"HTAB":   oprsDescr.HTAB,
		"LF":     oprsDescr.LF,
		"LWSP":   oprsDescr.LWSP,
		"OCTET":  oprsDescr.OCTET,
		"SP":     oprsDescr.SP,
		"VCHAR":  oprsDescr.VCHAR,
		"WSP":    oprsDescr.WSP,
	}
}

// RulesMap returns map of all rules.
func RulesMap() map[string]abnf.Rule {
	return map[string]abnf.Rule{
		"ALPHA":  rulesDescr.ALPHA,
		"BIT":    rulesDescr.BIT,
		"CHAR":   rulesDescr.CHAR,
		"CR":     rulesDescr.CR,
		"CRLF":   rulesDescr.CRLF,
		"CTL":    rulesDescr.CTL,
		"DIGIT":  rulesDescr.DIGIT,
		"DQUOTE": rulesDescr.DQUOTE,
		"HEXDIG": rulesDescr.HEXDIG,
		"HTAB":   rulesDescr.HTAB,
		"LF":     rulesDescr.LF,
		"LWSP":   rulesDescr.LWSP,
		"OCTET":  rulesDescr.OCTET,
		"SP":     rulesDescr.SP,
		"VCHAR":  rulesDescr.VCHAR,
		"WSP":    rulesDescr.WSP,
	}
}

// OperatorsDescr defines operators descriptor that provides operators as methods.
type OperatorsDescr struct {
	alpha      abnf.Operator
	alphaOnce  sync.Once
	bit        abnf.Operator
	bitOnce    sync.Once
	char       abnf.Operator
	charOnce   sync.Once
	cr         abnf.Operator
	crOnce     sync.Once
	crlf       abnf.Operator
	crlfOnce   sync.Once
	ctl        abnf.Operator
	ctlOnce    sync.Once
	digit      abnf.Operator
	digitOnce  sync.Once
	dquote     abnf.Operator
	dquoteOnce sync.Once
	hexdig     abnf.Operator
	hexdigOnce sync.Once
	htab       abnf.Operator
	htabOnce   sync.Once
	lf         abnf.Operator
	lfOnce     sync.Once
	lwsp       abnf.Operator
	lwspOnce   sync.Once
	octet      abnf.Operator
	octetOnce  sync.Once
	sp         abnf.Operator
	spOnce     sync.Once
	vchar      abnf.Operator
	vcharOnce  sync.Once
	wsp        abnf.Operator
	wspOnce    sync.Once
}

// ALPHA operator: ALPHA = %x41-5A / %x61-7A
func (desc *OperatorsDescr) ALPHA(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.alphaOnce.Do(func() {
		desc.alpha = abnf.Alt(
			"ALPHA",
			abnf.Range("%x41-5A", []byte{65}, []byte{90}),
			abnf.Range("%x61-7A", []byte{97}, []byte{122}),
		)
	})
	return desc.alpha(in, pos, ns) //errtrace:skip
}

// BIT operator: BIT = "0" / "1"
func (desc *OperatorsDescr) BIT(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.bitOnce.Do(func() {
		desc.bit = abnf.Alt(
			"BIT",
			abnf.Literal("\"0\"", []byte{48}),
			abnf.Literal("\"1\"", []byte{49}),
		)
	})
	return desc.bit(in, pos, ns) //errtrace:skip
}

// CHAR operator: CHAR = %x01-7F
func (desc *OperatorsDescr) CHAR(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.charOnce.Do(func() {
		desc.char = abnf.Range("CHAR", []byte{1}, []byte{127})
	})
	return desc.char(in, pos, ns) //errtrace:skip
}

// CR operator: CR = %x0D
func (desc *OperatorsDescr) CR(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.crOnce.Do(func() {
		desc.cr = abnf.Literal("CR", []byte{13})
	})
	return desc.cr(in, pos, ns) //errtrace:skip
}

// CRLF operator: CRLF = CR LF / LF
func (desc *OperatorsDescr) CRLF(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.crlfOnce.Do(func() {
		desc.crlf = abnf.Alt(
			"CRLF",
			abnf.Concat(
				"CR LF",
				desc.CR,
				desc.LF,
			),
			desc.LF,
		)
	})
	return desc.crlf(in, pos, ns) //errtrace:skip
}

// CTL operator: CTL = %x00-1F / %x7F
func (desc *OperatorsDescr) CTL(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.ctlOnce.Do(func() {
		desc.ctl = abnf.Alt(
			"CTL",
			abnf.Range("%x00-1F", []byte{0}, []byte{31}),
			abnf.Literal("%x7F", []byte{127}),
		)
	})
	return desc.ctl(in, pos, ns) //errtrace:skip
}

// DIGIT operator: DIGIT = %x30-39
func (desc *OperatorsDescr) DIGIT(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.digitOnce.Do(func() {
		desc.digit = abnf.Range("DIGIT", []byte{48}, []byte{57})
	})
	return desc.digit(in, pos, ns) //errtrace:skip
}

// DQUOTE operator: DQUOTE = %x22
func (desc *OperatorsDescr) DQUOTE(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.dquoteOnce.Do(func() {
		desc.dquote = abnf.Literal("DQUOTE", []byte{34})
	})
	return desc.dquote(in, pos, ns) //errtrace:skip
}

// HEXDIG operator: HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
func (desc *OperatorsDescr) HEXDIG(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.hexdigOnce.Do(func() {
		desc.hexdig = abnf.Alt(
			"HEXDIG",
			desc.DIGIT,
			abnf.Literal("\"A\"", []byte{65}),
			abnf.Literal("\"B\"", []byte{66}),
			abnf.Literal("\"C\"", []byte{67}),
			abnf.Literal("\"D\"", []byte{68}),
			abnf.Literal("\"E\"", []byte{69}),
			abnf.Literal("\"F\"", []byte{70}),
		)
	})
	return desc.hexdig(in, pos, ns) //errtrace:skip
}

// HTAB operator: HTAB = %x09
func (desc *OperatorsDescr) HTAB(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.htabOnce.Do(func() {
		desc.htab = abnf.Literal("HTAB", []byte{9})
	})
	return desc.htab(in, pos, ns) //errtrace:skip
}

// LF operator: LF = %x0A
func (desc *OperatorsDescr) LF(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.lfOnce.Do(func() {
		desc.lf = abnf.Literal("LF", []byte{10})
	})
	return desc.lf(in, pos, ns) //errtrace:skip
}

// LWSP operator: LWSP = *(WSP / CRLF WSP)
func (desc *OperatorsDescr) LWSP(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.lwspOnce.Do(func() {
		desc.lwsp = abnf.Repeat0Inf(
			"LWSP",
			abnf.Alt(
				"WSP / CRLF WSP",
				desc.WSP,
				abnf.Concat(
					"CRLF WSP",
					desc.CRLF,
					desc.WSP,
				),
			),
		)
	})
	return desc.lwsp(in, pos, ns) //errtrace:skip
}

// OCTET operator: OCTET = %x00-FF
func (desc *OperatorsDescr) OCTET(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.octetOnce.Do(func() {
		desc.octet = abnf.Range("OCTET", []byte{0}, []byte{255})
	})
	return desc.octet(in, pos, ns) //errtrace:skip
}

// SP operator: SP = %x20
func (desc *OperatorsDescr) SP(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.spOnce.Do(func() {
		desc.sp = abnf.Literal("SP", []byte{32})
	})
	return desc.sp(in, pos, ns) //errtrace:skip
}

// VCHAR operator: VCHAR = %x21-7E
func (desc *OperatorsDescr) VCHAR(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.vcharOnce.Do(func() {
		desc.vchar = abnf.Range("VCHAR", []byte{33}, []byte{126})
	})
	return desc.vchar(in, pos, ns) //errtrace:skip
}

// WSP operator: WSP = SP / HTAB
func (desc *OperatorsDescr) WSP(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.wspOnce.Do(func() {
		desc.wsp = abnf.Alt(
			"WSP",
			desc.SP,
			desc.HTAB,
		)
	})
	return desc.wsp(in, pos, ns) //errtrace:skip
}

// RulesDescr defines rules descriptor that provides rules as methods.
type RulesDescr struct{}

// ALPHA rule: ALPHA = %x41-5A / %x61-7A
func (*RulesDescr) ALPHA(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.ALPHA(in, 0, ns) //errtrace:skip
}

// BIT rule: BIT = "0" / "1"
func (*RulesDescr) BIT(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.BIT(in, 0, ns) //errtrace:skip
}

// CHAR rule: CHAR = %x01-7F
func (*RulesDescr) CHAR(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CHAR(in, 0, ns) //errtrace:skip
}

// CR rule: CR = %x0D
func (*RulesDescr) CR(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CR(in, 0, ns) //errtrace:skip
}

// CRLF rule: CRLF = CR LF / LF
func (*RulesDescr) CRLF(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CRLF(in, 0, ns) //errtrace:skip
}

// CTL rule: CTL = %x00-1F / %x7F
func (*RulesDescr) CTL(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.CTL(in, 0, ns) //errtrace:skip
}

// DIGIT rule: DIGIT = %x30-39
func (*RulesDescr) DIGIT(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.DIGIT(in, 0, ns) //errtrace:skip
}

// DQUOTE rule: DQUOTE = %x22
func (*RulesDescr) DQUOTE(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.DQUOTE(in, 0, ns) //errtrace:skip
}

// HEXDIG rule: HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
func (*RulesDescr) HEXDIG(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.HEXDIG(in, 0, ns) //errtrace:skip
}

// HTAB rule: HTAB = %x09
func (*RulesDescr) HTAB(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.HTAB(in, 0, ns) //errtrace:skip
}

// LF rule: LF = %x0A
func (*RulesDescr) LF(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.LF(in, 0, ns) //errtrace:skip
}

// LWSP rule: LWSP = *(WSP / CRLF WSP)
func (*RulesDescr) LWSP(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.LWSP(in, 0, ns) //errtrace:skip
}

// OCTET rule: OCTET = %x00-FF
func (*RulesDescr) OCTET(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.OCTET(in, 0, ns) //errtrace:skip
}

// SP rule: SP = %x20
func (*RulesDescr) SP(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.SP(in, 0, ns) //errtrace:skip
}

// VCHAR rule: VCHAR = %x21-7E
func (*RulesDescr) VCHAR(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.VCHAR(in, 0, ns) //errtrace:skip
}

// WSP rule: WSP = SP / HTAB
func (*RulesDescr) WSP(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.WSP(in, 0, ns) //errtrace:skip
}
