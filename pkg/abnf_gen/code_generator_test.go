package abnf_gen_test

import (
	"bytes"
	"os"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/ghettovoice/abnf/pkg/abnf_gen"
)

var _ = Describe("CodeGenerator", func() {
	DescribeTable("",
		func(abnfPath, expPath string, gen *abnf_gen.CodeGenerator) {
			raw, err := os.ReadFile(abnfPath)
			Expect(err).ShouldNot(HaveOccurred())

			src := bytes.NewBuffer(raw)
			Expect(gen.ReadFrom(src)).Error().ShouldNot(HaveOccurred())

			var dst bytes.Buffer
			Expect(gen.WriteTo(&dst)).Error().ShouldNot(HaveOccurred())

			exp, err := os.ReadFile(expPath)
			Expect(err).ShouldNot(HaveOccurred())

			Expect(dst.String()).Should(Equal(string(exp)))
		},
		Entry("rules.abnf",
			"../abnf_core/rules.abnf",
			"../abnf_core/rules.go",
			&abnf_gen.CodeGenerator{
				PackageName: "abnf_core",
				AsOperators: true,
			},
		),
		Entry("rules.abnf",
			"../abnf_def/rules.abnf",
			"../abnf_def/rules.go",
			&abnf_gen.CodeGenerator{
				PackageName: "abnf_def",
				AsOperators: true,
				External: map[string]abnf_gen.ExternalRule{
					"CRLF": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"WSP": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"BIT": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"VCHAR": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"DIGIT": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"HEXDIG": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"DQUOTE": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
					"ALPHA": {
						PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
						PackageName: "abnf_core",
						IsOperator:  true,
					},
				},
			},
		),
	)
})

func TestCodeGenerator_ReservedWords(t *testing.T) {
	RegisterTestingT(t)

	src := []byte(
		"var = type / struct\n" +
			"type = \"0\" / \"1\"\n" +
			"struct = %x41-5A / %x61-7A\n",
	)
	g := &abnf_gen.CodeGenerator{
		PackageName: "reserved_words",
		AsOperators: true,
	}
	if _, err := g.ReadFrom(bytes.NewReader(src)); err != nil {
		t.Fatal(err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatal(err)
	}

	want := `// This file is generated by abnf - DO NOT EDIT.

package reserved_words

import "github.com/ghettovoice/abnf"

var struct_ abnf.Operator

// Struct rule: struct = %x41-5A / %x61-7A
func Struct(s []byte, ns abnf.Nodes) abnf.Nodes {
	if struct_ == nil {
		struct_ = abnf.Alt(
			"struct",
			abnf.Range("%x41-5A", []byte{65}, []byte{90}),
			abnf.Range("%x61-7A", []byte{97}, []byte{122}),
		)
	}
	return struct_(s, ns)
}

var type_ abnf.Operator

// Type rule: type = "0" / "1"
func Type(s []byte, ns abnf.Nodes) abnf.Nodes {
	if type_ == nil {
		type_ = abnf.Alt(
			"type",
			abnf.Literal("\"0\"", []byte{48}),
			abnf.Literal("\"1\"", []byte{49}),
		)
	}
	return type_(s, ns)
}

var var_ abnf.Operator

// Var rule: var = type / struct
func Var(s []byte, ns abnf.Nodes) abnf.Nodes {
	if var_ == nil {
		var_ = abnf.Alt(
			"var",
			Type,
			Struct,
		)
	}
	return var_(s, ns)
}
`
	Expect(dst.String()).Should(Equal(want))
}

func TestCodeGenerator_ExtendRule(t *testing.T) {
	RegisterTestingT(t)

	rules := bytes.NewBuffer([]byte(
		"r1 = r2 / \"2\"\n" +
			"r2 = BIT / ALPHA\n" +
			"r1 =/ \"3\"\n",
	))
	g := &abnf_gen.CodeGenerator{
		PackageName: "extend_rule",
		AsOperators: true,
	}
	if _, err := g.ReadFrom(rules); err != nil {
		t.Fatal(err)
	}
	if _, err := g.ReadFrom(bytes.NewReader([]byte("r1 =/ \"4\"\n"))); err != nil {
		t.Fatal(err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatal(err)
	}

	want := `// This file is generated by abnf - DO NOT EDIT.

package extend_rule

import "github.com/ghettovoice/abnf"

var r1 abnf.Operator

// R1 rule: r1 = r2 / "2" / "3" / "4"
func R1(s []byte, ns abnf.Nodes) abnf.Nodes {
	if r1 == nil {
		r1 = abnf.Alt(
			"r1",
			R2,
			abnf.Literal("\"2\"", []byte{50}),
			abnf.Literal("\"3\"", []byte{51}),
			abnf.Literal("\"4\"", []byte{52}),
		)
	}
	return r1(s, ns)
}

var r2 abnf.Operator

// R2 rule: r2 = BIT / ALPHA
func R2(s []byte, ns abnf.Nodes) abnf.Nodes {
	if r2 == nil {
		r2 = abnf.Alt(
			"r2",
			BIT,
			ALPHA,
		)
	}
	return r2(s, ns)
}
`
	Expect(dst.String()).Should(Equal(want))
}
