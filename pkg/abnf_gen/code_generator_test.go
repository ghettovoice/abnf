package abnf_gen_test

import (
	"bytes"
	"fmt"
	"os"
	"testing"

	"github.com/ghettovoice/abnf/pkg/abnf_gen"
	"github.com/google/go-cmp/cmp"
)

func TestCodeGenerator_WriteTo(t *testing.T) {
	src, err := os.ReadFile("../abnf_def/rules.abnf")
	if err != nil {
		t.Fatalf("read ABNF file failed: %v", err)
	}

	g := &abnf_gen.CodeGenerator{
		PackageName: "abnf_def",
		External: map[string]abnf_gen.ExternalRule{
			"CRLF": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"WSP": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"BIT": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"VCHAR": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"DIGIT": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"HEXDIG": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"DQUOTE": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
			"ALPHA": {
				PackagePath: "github.com/ghettovoice/abnf/pkg/abnf_core",
				PackageName: "abnf_core",
			},
		},
	}
	if _, err := g.ReadFrom(bytes.NewReader(src)); err != nil {
		t.Fatalf("g.ReadFrom(src) error = %v, want nil", err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatalf("g.WriteTo(&dst) error = %v, want nil", err)
	}

	want, err := os.ReadFile("../abnf_def/rules.go")
	if err != nil {
		t.Fatalf("read expected Go file failed: %v", err)
	}

	if got, want := dst.String(), string(want); got != want {
		t.Fatalf("got != want\ndiff (-got +want)\n%v", cmp.Diff(got, want))
	}
}

func TestCodeGenerator_ReservedWords(t *testing.T) {
	src := []byte(
		"var = type / struct\n" +
			"type = \"0\" / \"1\"\n" +
			"struct = %x41-5A / %x61-7A\n",
	)
	g := &abnf_gen.CodeGenerator{
		PackageName: "reserved_words",
	}
	if _, err := g.ReadFrom(bytes.NewReader(src)); err != nil {
		t.Fatal(err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatal(err)
	}

	want := `// This file is generated by abnf - DO NOT EDIT.

package reserved_words

import (
	"sync"

	"github.com/ghettovoice/abnf"
)

var (
	oprsDescr  = &OperatorsDescr{}
	rulesDescr = &RulesDescr{}
)

// Operators returns operators descriptor.
func Operators() *OperatorsDescr {
	return oprsDescr
}

// Rules returns rules descriptor.
func Rules() *RulesDescr {
	return rulesDescr
}

// OperatorsMap returns map of all operators.
func OperatorsMap() map[string]abnf.Operator {
	return map[string]abnf.Operator{
		"struct": oprsDescr.Struct,
		"type":   oprsDescr.Type,
		"var":    oprsDescr.Var,
	}
}

// RulesMap returns map of all rules.
func RulesMap() map[string]abnf.Rule {
	return map[string]abnf.Rule{
		"struct": rulesDescr.Struct,
		"type":   rulesDescr.Type,
		"var":    rulesDescr.Var,
	}
}

// OperatorsDescr defines operators descriptor that provides operators as methods.
type OperatorsDescr struct {
	_struct     abnf.Operator
	_structOnce sync.Once
	_type       abnf.Operator
	_typeOnce   sync.Once
	_var        abnf.Operator
	_varOnce    sync.Once
}

// Struct operator: struct = %x41-5A / %x61-7A
func (desc *OperatorsDescr) Struct(in []byte, pos uint, ns *abnf.Nodes) error {
	desc._structOnce.Do(func() {
		desc._struct = abnf.Alt(
			"struct",
			abnf.Range("%x41-5A", []byte{65}, []byte{90}),
			abnf.Range("%x61-7A", []byte{97}, []byte{122}),
		)
	})
	return desc._struct(in, pos, ns) //errtrace:skip
}

// Type operator: type = "0" / "1"
func (desc *OperatorsDescr) Type(in []byte, pos uint, ns *abnf.Nodes) error {
	desc._typeOnce.Do(func() {
		desc._type = abnf.Alt(
			"type",
			abnf.Literal("\"0\"", []byte{48}),
			abnf.Literal("\"1\"", []byte{49}),
		)
	})
	return desc._type(in, pos, ns) //errtrace:skip
}

// Var operator: var = type / struct
func (desc *OperatorsDescr) Var(in []byte, pos uint, ns *abnf.Nodes) error {
	desc._varOnce.Do(func() {
		desc._var = abnf.Alt(
			"var",
			desc.Type,
			desc.Struct,
		)
	})
	return desc._var(in, pos, ns) //errtrace:skip
}

// RulesDescr defines rules descriptor that provides rules as methods.
type RulesDescr struct{}

// Struct rule: struct = %x41-5A / %x61-7A
func (*RulesDescr) Struct(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Struct(in, 0, ns) //errtrace:skip
}

// Type rule: type = "0" / "1"
func (*RulesDescr) Type(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Type(in, 0, ns) //errtrace:skip
}

// Var rule: var = type / struct
func (*RulesDescr) Var(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.Var(in, 0, ns) //errtrace:skip
}
`

	if got := dst.String(); got != want {
		t.Fatalf("got != want\ndiff (-got +want)\n%v", cmp.Diff(got, want))
	}
}

func TestCodeGenerator_ExtendRule(t *testing.T) {
	rules := bytes.NewBuffer([]byte(
		"r1 = r2 / \"2\"\n" +
			"r2 = BIT / ALPHA\n" +
			"r1 =/ \"3\"\n",
	))
	g := &abnf_gen.CodeGenerator{
		PackageName: "extend_rule",
	}
	if _, err := g.ReadFrom(rules); err != nil {
		t.Fatal(err)
	}
	if _, err := g.ReadFrom(bytes.NewReader([]byte("r1 =/ \"4\"\n"))); err != nil {
		t.Fatal(err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatal(err)
	}

	want := `// This file is generated by abnf - DO NOT EDIT.

package extend_rule

import (
	"sync"

	"github.com/ghettovoice/abnf"
)

var (
	oprsDescr  = &OperatorsDescr{}
	rulesDescr = &RulesDescr{}
)

// Operators returns operators descriptor.
func Operators() *OperatorsDescr {
	return oprsDescr
}

// Rules returns rules descriptor.
func Rules() *RulesDescr {
	return rulesDescr
}

// OperatorsMap returns map of all operators.
func OperatorsMap() map[string]abnf.Operator {
	return map[string]abnf.Operator{
		"r1": oprsDescr.R1,
		"r2": oprsDescr.R2,
	}
}

// RulesMap returns map of all rules.
func RulesMap() map[string]abnf.Rule {
	return map[string]abnf.Rule{
		"r1": rulesDescr.R1,
		"r2": rulesDescr.R2,
	}
}

// OperatorsDescr defines operators descriptor that provides operators as methods.
type OperatorsDescr struct {
	r1     abnf.Operator
	r1Once sync.Once
	r2     abnf.Operator
	r2Once sync.Once
}

// R1 operator: r1 = r2 / "2" / "3" / "4"
func (desc *OperatorsDescr) R1(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.r1Once.Do(func() {
		desc.r1 = abnf.Alt(
			"r1",
			desc.R2,
			abnf.Literal("\"2\"", []byte{50}),
			abnf.Literal("\"3\"", []byte{51}),
			abnf.Literal("\"4\"", []byte{52}),
		)
	})
	return desc.r1(in, pos, ns) //errtrace:skip
}

// R2 operator: r2 = BIT / ALPHA
func (desc *OperatorsDescr) R2(in []byte, pos uint, ns *abnf.Nodes) error {
	desc.r2Once.Do(func() {
		desc.r2 = abnf.Alt(
			"r2",
			desc.BIT,
			desc.ALPHA,
		)
	})
	return desc.r2(in, pos, ns) //errtrace:skip
}

// RulesDescr defines rules descriptor that provides rules as methods.
type RulesDescr struct{}

// R1 rule: r1 = r2 / "2" / "3" / "4"
func (*RulesDescr) R1(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.R1(in, 0, ns) //errtrace:skip
}

// R2 rule: r2 = BIT / ALPHA
func (*RulesDescr) R2(in []byte, ns *abnf.Nodes) error {
	return oprsDescr.R2(in, 0, ns) //errtrace:skip
}
`

	if got := dst.String(); got != want {
		t.Fatalf("got != want\ndiff (-got +want)\n%v", cmp.Diff(got, want))
	}
}

func TestCodeGenerator_tmp(t *testing.T) {
	rules := bytes.NewBuffer([]byte(
		"r1 = \"1\" / \"2\"\n" +
			"r2 = r1\n",
	))
	g := &abnf_gen.CodeGenerator{
		PackageName: "extend_rule",
	}
	if _, err := g.ReadFrom(rules); err != nil {
		t.Fatal(err)
	}

	var dst bytes.Buffer
	if _, err := g.WriteTo(&dst); err != nil {
		t.Fatal(err)
	}
	fmt.Println(dst.String())
}
