package abnf_gen

import (
	"bytes"
	"fmt"
	"io"
	"sort"

	"braces.dev/errtrace"
	"github.com/dave/jennifer/jen"
	"mvdan.cc/gofumpt/format"
)

// CodeGenerator generates ABNF rules as Go sources.
type CodeGenerator struct {
	// External ABNF rules.
	External map[string]ExternalRule
	// Package name for generated sources.
	PackageName string

	rulesParser

	code     bytes.Buffer
	ruleName string
}

const mainPkg = "github.com/ghettovoice/abnf"

// ReadFrom reads and parses ABNF grammar from src.
func (g *CodeGenerator) ReadFrom(src io.Reader) (int64, error) {
	if g.code.Len() > 0 {
		g.code.Reset()
	}
	return errtrace.Wrap2(g.rulesParser.ReadFrom(src))
}

// WriteTo generates final Go sources and writes them to dst.
func (g *CodeGenerator) WriteTo(dst io.Writer) (int64, error) {
	if g.code.Len() == 0 {
		f := jen.NewFile(g.PackageName)
		f.HeaderComment("This file is generated by abnf - DO NOT EDIT.")

		f.ImportName("sync", "")
		f.ImportName(mainPkg, "abnf")
		for _, extRule := range g.External {
			if extRule.PackagePath != "" && extRule.PackageName != "" {
				f.ImportName(extRule.PackagePath, extRule.PackageName)
			}
		}

		rs := make([]rule, 0, len(g.rules))
		for _, r := range g.rules {
			rs = append(rs, r)
		}
		sort.Slice(rs, func(i, j int) bool {
			return rs[i].pubName() < rs[j].pubName()
		})

		f.Var().Defs(
			jen.Id("oprsDescr").Op("=").Op("&").Qual("", "OperatorsDescr").Values(),
			jen.Id("rulesDescr").Op("=").Op("&").Qual("", "RulesDescr").Values(),
		)

		f.Comment("Operators returns operators descriptor.")
		f.Func().Id("Operators").Params().Op("*").Qual("", "OperatorsDescr").
			Block(jen.Return(jen.Id("oprsDescr"))).
			Line()

		f.Comment("Rules returns rules descriptor.")
		f.Func().Id("Rules").Params().Op("*").Qual("", "RulesDescr").
			Block(jen.Return(jen.Id("rulesDescr"))).
			Line()

		var oprsMethods, oprsFields, rulesMethods []jen.Code
		oprsMapElems := make(jen.Dict, len(rs))
		rulesMapElems := make(jen.Dict, len(rs))
		for _, r := range rs {
			opStmt := jen.
				Commentf("%s operator: %s = %s", r.pubName(), r.name, r.oprt.key()).
				Line().
				Func().
				Params(jen.Id("desc").Op("*").Qual("", "OperatorsDescr")).
				Id(r.pubName()).
				Params(
					jen.Id("in").Index().Byte(),
					jen.Id("pos").Uint(),
					jen.Id("ns").Op("*").Qual(mainPkg, "Nodes"),
				).
				Error().
				Block(
					jen.Id("desc").Dot(r.privName()+"Once").Dot("Do").Call(
						jen.Func().Params().Block(
							jen.Id("desc").Dot(r.privName()).Op("=").Add(r.buildStmt(g)),
						),
					),
					jen.Return(
						jen.Id("desc").Dot(r.privName()).Call(
							jen.Id("in"),
							jen.Id("pos"),
							jen.Id("ns"),
						),
					).Comment("//errtrace:skip"),
				).
				Line()
			oprsMethods = append(oprsMethods, opStmt)

			oprsFields = append(oprsFields,
				jen.Id(r.privName()).Qual(mainPkg, "Operator"),
				jen.Id(r.privName()+"Once").Qual("sync", "Once"),
			)

			oprsMapElems[jen.Lit(r.name)] = jen.Id("oprsDescr").Dot(r.pubName())

			ruleStmt := jen.
				Commentf("%s rule: %s = %s", r.pubName(), r.name, r.oprt.key()).
				Line().
				Func().
				Params(jen.Op("*").Qual("", "RulesDescr")).
				Id(r.pubName()).
				Params(
					jen.Id("in").Index().Byte(),
					jen.Id("ns").Op("*").Qual(mainPkg, "Nodes"),
				).
				Error().
				Block(
					jen.Return(
						jen.Id("oprsDescr").Dot(r.pubName()).Call(
							jen.Id("in"),
							jen.Lit(0),
							jen.Id("ns"),
						),
					).Comment("//errtrace:skip"),
				).
				Line()
			rulesMethods = append(rulesMethods, ruleStmt)

			rulesMapElems[jen.Lit(r.name)] = jen.Id("rulesDescr").Dot(r.pubName())
		}

		f.Comment("OperatorsMap returns map of all operators.")
		f.Func().
			Id("OperatorsMap").
			Params().
			Map(jen.String()).Qual(mainPkg, "Operator").
			Block(
				jen.Return(
					jen.Map(jen.String()).Qual(mainPkg, "Operator").
						Values(oprsMapElems),
				),
			).
			Line()

		f.Comment("RulesMap returns map of all rules.")
		f.Func().
			Id("RulesMap").
			Params().
			Map(jen.String()).Qual(mainPkg, "Rule").
			Block(
				jen.Return(
					jen.Map(jen.String()).Qual(mainPkg, "Rule").
						Values(rulesMapElems),
				),
			).
			Line()

		f.Comment("OperatorsDescr defines operators descriptor that provides operators as methods.")
		f.Type().Id("OperatorsDescr").Struct(oprsFields...).Line()
		f.Add(oprsMethods...)

		f.Comment("RulesDescr defines rules descriptor that provides rules as methods.")
		f.Type().Id("RulesDescr").Struct().Line()
		f.Add(rulesMethods...)

		if err := f.Render(&g.code); err != nil {
			return 0, errtrace.Wrap(fmt.Errorf("generate code: %w", err))
		}

		if src, err := format.Source(g.code.Bytes(), format.Options{ExtraRules: true}); err == nil {
			g.code.Reset()
			g.code.Write(src)
		} else {
			return 0, errtrace.Wrap(fmt.Errorf("format code: %w", err))
		}
	}

	num, err := dst.Write(g.code.Bytes())
	if err != nil {
		err = fmt.Errorf("write code: %w", err)
	}
	return int64(num), errtrace.Wrap(err)
}

func (g *CodeGenerator) oprtKey(key string) string {
	if g.ruleName != "" {
		key = g.ruleName
		g.ruleName = ""
	}
	return key
}

type statementBuilder interface {
	buildStmt(g *CodeGenerator) jen.Code
}

func (r rule) buildStmt(g *CodeGenerator) jen.Code {
	g.ruleName = r.name
	return r.oprt.buildStmt(g)
}

func (op altOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Alt").
		CustomFunc(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			func(args *jen.Group) {
				args.Add(jen.Lit(g.oprtKey(op.key())))
				for _, op := range op.oprts {
					args.Add(op.buildStmt(g))
				}
				args.Add(jen.Empty())
			},
		)
}

func (op concatOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Concat").
		CustomFunc(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			func(args *jen.Group) {
				args.Add(jen.Lit(g.oprtKey(op.key())))
				for _, op := range op.oprts {
					args.Add(op.buildStmt(g))
				}
				args.Add(jen.Empty())
			},
		)
}

func (op repeatOperator) buildStmt(g *CodeGenerator) jen.Code {
	if op.max == 0 && (op.min == 0 || op.min == 1) {
		var fnName string
		if op.min == 0 {
			fnName = "Repeat0Inf"
		} else {
			fnName = "Repeat1Inf"
		}
		return jen.Qual(mainPkg, fnName).
			Custom(
				jen.Options{
					Open:      "(",
					Close:     ")",
					Separator: ", ",
					Multi:     true,
				},
				jen.Lit(g.oprtKey(op.key())),
				op.oprt.buildStmt(g),
				jen.Empty(),
			)
	}

	if op.min == op.max {
		return jen.Qual(mainPkg, "RepeatN").
			Custom(
				jen.Options{
					Open:      "(",
					Close:     ")",
					Separator: ", ",
					Multi:     true,
				},
				jen.Lit(g.oprtKey(op.key())),
				jen.Lit(op.min),
				op.oprt.buildStmt(g),
				jen.Empty(),
			)
	}

	return jen.Qual(mainPkg, "Repeat").
		Custom(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			jen.Lit(g.oprtKey(op.key())),
			jen.Lit(op.min),
			jen.Lit(op.max),
			op.oprt.buildStmt(g),
			jen.Empty(),
		)
}

func (op ruleNameOperator) buildStmt(g *CodeGenerator) jen.Code {
	if extRule, ok := g.External[op.key()]; ok {
		if extRule.PackagePath == "" {
			panic(fmt.Errorf("invalid external ABNF rule '%s' found: 'PackagePath' field is empty", op.key()))
		}

		stmt := jen.Qual(extRule.PackagePath, "Operators").Call().Dot(fmtPubRuleName(op.key()))
		return stmt
	}

	stmt := jen.Id("desc").Dot(fmtPubRuleName(op.key()))
	return stmt
}

func (op optionOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Optional").
		Custom(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			jen.Lit(g.oprtKey(op.key())),
			op.oprt.buildStmt(g),
			jen.Empty(),
		)
}

func (op charValOperator) buildStmt(g *CodeGenerator) jen.Code {
	fnName := "Literal"
	if op.cs {
		fnName = "LiteralCS"
	}
	return jen.Qual(mainPkg, fnName).Call(
		jen.Lit(g.oprtKey(op.key())),
		jen.Index().Byte().ValuesFunc(func(vals *jen.Group) {
			for _, b := range []byte(op.val) {
				vals.Add(jen.Lit(int(b)))
			}
		}),
	)
}

func (op numValOperator) buildStmt(g *CodeGenerator) jen.Code {
	vals := op.byteVals()

	if op.isRange {
		return jen.Qual(mainPkg, "Range").Call(
			jen.Lit(g.oprtKey(op.key())),
			jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
				for _, b := range vals[0] {
					args.Add(jen.Lit(int(b)))
				}
			}),
			jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
				for _, b := range vals[1] {
					args.Add(jen.Lit(int(b)))
				}
			}),
		)
	}

	return jen.Qual(mainPkg, "Literal").Call(
		jen.Lit(g.oprtKey(op.key())),
		jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
			for _, v := range vals {
				for _, b := range v {
					args.Add(jen.Lit(int(b)))
				}
			}
		}),
	)
}
