package abnf_gen

import (
	"bytes"
	"fmt"
	"io"
	"sort"

	"github.com/dave/jennifer/jen"
)

// CodeGenerator generates ABNF rules as Go sources.
type CodeGenerator struct {
	External    map[string]ExternalRule
	PackageName string
	AsOperators bool

	rulesParser

	code     bytes.Buffer
	ruleName string
}

const mainPkg = "github.com/ghettovoice/abnf"

// ReadFrom reads and parses ABNF grammar from src.
func (g *CodeGenerator) ReadFrom(src io.Reader) (int64, error) {
	if g.code.Len() > 0 {
		g.code.Reset()
	}
	return g.rulesParser.ReadFrom(src)
}

// WriteTo generates final Go sources and writes them to the dst.
func (g *CodeGenerator) WriteTo(dst io.Writer) (int64, error) {
	if g.code.Len() == 0 {
		f := jen.NewFile(g.PackageName)
		f.HeaderComment("This file is generated by abnf - DO NOT EDIT.")

		f.ImportName(mainPkg, "abnf")
		for _, extRule := range g.External {
			if extRule.PackagePath != "" && extRule.PackageName != "" {
				f.ImportName(extRule.PackagePath, extRule.PackageName)
			}
		}

		rs := make([]rule, 0, len(g.rules))
		for _, r := range g.rules {
			rs = append(rs, r)
		}
		sort.Slice(rs, func(i, j int) bool {
			return rs[i].pubName() < rs[j].pubName()
		})

		for _, r := range rs {
			f.Add(r.buildStmt(g))
		}
		if err := f.Render(&g.code); err != nil {
			return 0, fmt.Errorf("generate code: %w", err)
		}
	}

	num, err := dst.Write(g.code.Bytes())
	if err != nil {
		err = fmt.Errorf("write code: %w", err)
	}
	return int64(num), err
}

func (g *CodeGenerator) oprtKey(key string) string {
	if g.ruleName != "" {
		key = g.ruleName
		g.ruleName = ""
	}
	return key
}

type statementBuilder interface {
	buildStmt(g *CodeGenerator) jen.Code
}

func (r rule) buildStmt(g *CodeGenerator) jen.Code {
	g.ruleName = r.name

	stmt := jen.Var().Id(r.privName()).Qual(mainPkg, "Operator").
		Line().
		Commentf("%s rule: %s = %s", r.pubName(), r.name, r.oprt.key()).
		Line().
		Func().Id(r.pubName())
	if g.AsOperators {
		stmt = stmt.Params(
			jen.Id("s").Index().Byte(),
			jen.Id("ns").Qual(mainPkg, "Nodes"),
		).Qual(mainPkg, "Nodes")
	} else {
		stmt = stmt.Params().Qual(mainPkg, "Operator")
	}
	return stmt.Block(
		jen.If(jen.Id(r.privName()).Op("==").Nil()).
			Block(jen.Id(r.privName()).Op("=").Add(r.oprt.buildStmt(g))),
		jen.ReturnFunc(func(args *jen.Group) {
			stmt := jen.Id(r.privName())
			if g.AsOperators {
				stmt = stmt.Call(jen.Id("s"), jen.Id("ns"))
			}
			args.Add(stmt)
		}),
	)
}

func (op altOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Alt").
		CustomFunc(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			func(args *jen.Group) {
				args.Add(jen.Lit(g.oprtKey(op.key())))
				for _, op := range op.oprts {
					args.Add(op.buildStmt(g))
				}
				args.Add(jen.Empty())
			},
		)
}

func (op concatOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Concat").
		CustomFunc(
			jen.Options{
				Open:      "(",
				Close:     ")",
				Separator: ", ",
				Multi:     true,
			},
			func(args *jen.Group) {
				args.Add(jen.Lit(g.oprtKey(op.key())))
				for _, op := range op.oprts {
					args.Add(op.buildStmt(g))
				}
				args.Add(jen.Empty())
			},
		)
}

func (op repeatOperator) buildStmt(g *CodeGenerator) jen.Code {
	if op.max == 0 && (op.min == 0 || op.min == 1) {
		var fnName string
		if op.min == 0 {
			fnName = "Repeat0Inf"
		} else {
			fnName = "Repeat1Inf"
		}
		return jen.Qual(mainPkg, fnName).
			Call(
				jen.Lit(g.oprtKey(op.key())),
				op.oprt.buildStmt(g),
			)
	}

	if op.min == op.max {
		return jen.Qual(mainPkg, "RepeatN").
			Call(
				jen.Lit(g.oprtKey(op.key())),
				jen.Lit(op.min),
				op.oprt.buildStmt(g),
			)
	}

	return jen.Qual(mainPkg, "Repeat").
		Call(
			jen.Lit(g.oprtKey(op.key())),
			jen.Lit(op.min),
			jen.Lit(op.max),
			op.oprt.buildStmt(g),
		)
}

func (op ruleNameOperator) buildStmt(g *CodeGenerator) jen.Code {
	if extRule, ok := g.External[op.key()]; ok {
		if extRule.PackagePath == "" {
			panic(fmt.Errorf("invalid external ABNF rule '%s' found: 'PackagePath' field is empty", op.key()))
		}

		stmt := jen.Qual(extRule.PackagePath, fmtPubRuleName(op.key()))
		if !extRule.IsOperator {
			stmt = stmt.Call()
		}
		return stmt
	}

	stmt := jen.Id(fmtPubRuleName(op.key()))
	if !g.AsOperators {
		stmt = stmt.Call()
	}
	return stmt
}

func (op optionOperator) buildStmt(g *CodeGenerator) jen.Code {
	return jen.Qual(mainPkg, "Optional").
		Call(
			jen.Lit(g.oprtKey(op.key())),
			op.oprt.buildStmt(g),
		)
}

func (op charValOperator) buildStmt(g *CodeGenerator) jen.Code {
	fnName := "Literal"
	if op.cs {
		fnName = "LiteralCS"
	}
	return jen.Qual(mainPkg, fnName).Call(
		jen.Lit(g.oprtKey(op.key())),
		jen.Index().Byte().ValuesFunc(func(vals *jen.Group) {
			for _, b := range []byte(op.val) {
				vals.Add(jen.Lit(int(b)))
			}
		}),
	)
}

func (op numValOperator) buildStmt(g *CodeGenerator) jen.Code {
	vals := op.byteVals()

	if op.isRange {
		return jen.Qual(mainPkg, "Range").Call(
			jen.Lit(g.oprtKey(op.key())),
			jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
				for _, b := range vals[0] {
					args.Add(jen.Lit(int(b)))
				}
			}),
			jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
				for _, b := range vals[1] {
					args.Add(jen.Lit(int(b)))
				}
			}),
		)
	}

	return jen.Qual(mainPkg, "Literal").Call(
		jen.Lit(g.oprtKey(op.key())),
		jen.Index().Byte().ValuesFunc(func(args *jen.Group) {
			for _, v := range vals {
				for _, b := range v {
					args.Add(jen.Lit(int(b)))
				}
			}
		}),
	)
}
